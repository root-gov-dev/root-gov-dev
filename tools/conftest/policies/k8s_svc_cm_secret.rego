package k8s.governance

# File purpose:
#   Unified governance policy for Service/ConfigMap/Secret.
#   Covers naming pattern, required labels, and resource-specific constraints.
#   ExternalName domains are loaded from data["policy-data"] generated by CI (defaults to svc.cluster.local).
#
# Data injection:
#   conftest test -p tools/conftest/policies -d conftest/data manifests
#   -> conftest/data/policy-data.json becomes data["policy-data"] in Rego.
#
# Notes:
#   - Keep rules deterministic and auditable.
#   - "exemption.*.approved: true" annotations are honored as explicit allowlist gates.

default deny = []

target_kinds := {"Service", "ConfigMap", "Secret"}

required_labels := {
  "namespace.io/team",
  "namespace.io/environment",
  "namespace.io/lifecycle",
  "namespace.io/managed-by",
  "namespace.io/contract-ref",
}

allowed_envs := {"production", "staging", "dev", "test"}
allowed_lifecycle := {"active", "deprecated", "retired"}
allowed_managed_by := {"gitops", "helm", "kustomize", "manual"}

# ------- Helpers: ExternalName allowed domains (from policy-data or default) -------

get_allowed_domains() = ds {
  # Prefer CI-injected policy-data
  ds := data["policy-data"].externalname.allowed_internal_domains
} else = ds {
  # Fallback default
  ds := ["svc.cluster.local"]
}

domain_allowed(host) {
  # Allow subdomains of any allowed domain
  some i
  ds := get_allowed_domains()
  d := ds[i]
  suffix := sprintf(".%s", [d])
  endswith(host, suffix)
} or {
  # Or exact match of an allowed domain
  ds := get_allowed_domains()
  host == ds[_]
}

is_target {
  target_kinds[input.kind]
}

# ------- Generic naming and required labels -------

deny[msg] {
  is_target
  not re_match("^(team|tenant|feature)-[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$", input.metadata.name)
  msg := sprintf("%s/%s: name violates pattern ^(team|tenant|feature)-[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$", [input.kind, input.metadata.name])
}

deny[msg] {
  is_target
  count(input.metadata.name) > 63
  msg := sprintf("%s/%s: name length exceeds 63 chars", [input.kind, input.metadata.name])
}

deny[msg] {
  is_target
  some k
  k := required_labels[_]
  not input.metadata.labels[k]
  msg := sprintf("%s/%s: missing label %q", [input.kind, input.metadata.name, k])
}

# Label value validations
deny[msg] {
  is_target
  val := input.metadata.labels["namespace.io/environment"]
  not allowed_envs[val]
  msg := sprintf("%s/%s: label namespace.io/environment must be one of %v", [input.kind, input.metadata.name, allowed_envs])
}

deny[msg] {
  is_target
  val := input.metadata.labels["namespace.io/lifecycle"]
  not allowed_lifecycle[val]
  msg := sprintf("%s/%s: label namespace.io/lifecycle must be one of %v", [input.kind, input.metadata.name, allowed_lifecycle])
}

deny[msg] {
  is_target
  val := input.metadata.labels["namespace.io/managed-by"]
  not allowed_managed_by[val]
  msg := sprintf("%s/%s: label namespace.io/managed-by must be one of %v", [input.kind, input.metadata.name, allowed_managed_by])
}

deny[msg] {
  is_target
  not re_match("^urn:namespace:contract:[a-z0-9._-]+:v[0-9]+$", input.metadata.labels["namespace.io/contract-ref"])
  msg := sprintf("%s/%s: label namespace.io/contract-ref must be URN (urn:namespace:contract:<domain>:vN)", [input.kind, input.metadata.name])
}

# ------- Service-specific constraints -------

deny[msg] {
  input.kind == "Service"
  input.spec.type == "LoadBalancer"
  not (input.metadata.annotations["exemption.loadbalancer.approved"] == "true")
  msg := sprintf("Service/%s: LoadBalancer not approved (add annotation exemption.loadbalancer.approved: \"true\")", [input.metadata.name])
}

deny[msg] {
  input.kind == "Service"
  input.spec.type == "NodePort"
  not (input.metadata.annotations["exemption.nodeport.approved"] == "true")
  msg := sprintf("Service/%s: NodePort not approved (add annotation exemption.nodeport.approved: \"true\")", [input.metadata.name])
}

deny[msg] {
  input.kind == "Service"
  input.spec.externalIPs
  msg := sprintf("Service/%s: externalIPs are disallowed", [input.metadata.name])
}

# ExternalName restriction (avoid uncontrolled DNS unless approved or in allowed domains)
deny[msg] {
  input.kind == "Service"
  input.spec.type == "ExternalName"
  ext := input.spec.externalName
  not (input.metadata.annotations["exemption.externalname.approved"] == "true")
  not domain_allowed(ext)
  msg := sprintf("Service/%s: ExternalName %q not in allowed internal domains %v (or missing exemption.externalname.approved=true)", [input.metadata.name, ext, get_allowed_domains()])
}

# selector must carry app labels
deny[msg] {
  input.kind == "Service"
  not input.spec.selector["app.kubernetes.io/name"]
  msg := sprintf("Service/%s: selector must include app.kubernetes.io/name", [input.metadata.name])
}

deny[msg] {
  input.kind == "Service"
  not input.spec.selector["app.kubernetes.io/instance"]
  msg := sprintf("Service/%s: selector must include app.kubernetes.io/instance", [input.metadata.name])
}

# ports must be named and have protocol
deny[msg] {
  input.kind == "Service"
  some i
  p := input.spec.ports[i]
  not p.name
  msg := sprintf("Service/%s: port at index %d must have a semantic name", [input.metadata.name, i])
}

deny[msg] {
  input.kind == "Service"
  some i
  p := input.spec.ports[i]
  p.protocol
  not (p.protocol == "TCP" or p.protocol == "UDP")
  msg := sprintf("Service/%s: port %q must declare protocol TCP/UDP", [input.metadata.name, p.name])
}

deny[msg] {
  input.kind == "Service"
  some i
  p := input.spec.ports[i]
  p.name
  not re_match("^[a-z][a-z0-9-]{0,61}[a-z0-9]$", p.name)
  msg := sprintf("Service/%s: port name %q must match ^[a-z][a-z0-9-]{0,61}[a-z0-9]$", [input.metadata.name, p.name])
}

# ------- ConfigMap-specific constraints -------

deny[msg] {
  input.kind == "ConfigMap"
  input.immutable != true
  msg := sprintf("ConfigMap/%s: immutable must be true", [input.metadata.name])
}

# Key name pattern and allowed double extensions
deny[msg] {
  input.kind == "ConfigMap"
  some k
  not valid_cm_key(k)
  msg := sprintf("ConfigMap/%s: key %q must end with one of .json.txt|.yaml.txt|.toml.txt|.env.txt and match ^[a-z0-9._-]+$", [input.metadata.name, k])
}

# Sensitive key names are banned in ConfigMap
deny[msg] {
  input.kind == "ConfigMap"
  some k
  sensitive_key(k)
  msg := sprintf("ConfigMap/%s: suspicious key name %q (use Secret instead)", [input.metadata.name, k])
}

# Per-value size limit (approximate by char length, <= 1 MiB)
deny[msg] {
  input.kind == "ConfigMap"
  some k
  v := input.data[k]
  count(v) > 1048576
  msg := sprintf("ConfigMap/%s: value for key %q exceeds 1MiB", [input.metadata.name, k])
}

# Require CI annotations for versioning and integrity
deny[msg] {
  input.kind == "ConfigMap"
  not input.metadata.annotations["integrity.hashes"]
  msg := sprintf("ConfigMap/%s: missing annotation integrity.hashes", [input.metadata.name])
}

deny[msg] {
  input.kind == "ConfigMap"
  not input.metadata.annotations["config.version"]
  msg := sprintf("ConfigMap/%s: missing annotation config.version", [input.metadata.name])
}

# ------- Secret-specific constraints -------

allowed_secret_types := {"Opaque", "kubernetes.io/dockerconfigjson", "kubernetes.io/tls"}

deny[msg] {
  input.kind == "Secret"
  not allowed_secret_types[input.type]
  msg := sprintf("Secret/%s: type %q not allowed", [input.metadata.name, input.type])
}

deny[msg] {
  input.kind == "Secret"
  cl := input.metadata.annotations["data.classification"]
  not (cl == "confidential" or cl == "restricted")
  msg := sprintf("Secret/%s: annotation data.classification must be confidential|restricted", [input.metadata.name])
}

deny[msg] {
  input.kind == "Secret"
  kr := input.metadata.annotations["key-rotation"]
  not (kr == "30d" or kr == "90d")
  msg := sprintf("Secret/%s: annotation key-rotation must be 30d|90d", [input.metadata.name])
}

# Base64-like value check (regex + length mod 4 == 0)
deny[msg] {
  input.kind == "Secret"
  some k
  v := input.data[k]
  not is_base64_like(v)
  msg := sprintf("Secret/%s: key %q value must be base64-encoded (no nested or reversible encodings)", [input.metadata.name, k])
}

# ------- Helpers -------

valid_cm_key(k) {
  re_match("^[a-z0-9._-]+$", k)
  endswith_any(k, [".json.txt", ".yaml.txt", ".toml.txt", ".env.txt"])
}

endswith_any(s, xs) {
  some i
  endswith(s, xs[i])
}

sensitive_key(k) {
  lk := lower(k)
  lk == "password" or
  lk == "secret" or
  lk == "token" or
  lk == "apikey" or
  lk == "api_key" or
  lk == "private_key"
}

is_base64_like(s) {
  re_match("^[A-Za-z0-9+/=]+$", s)
  mod4(count(s))
}

mod4(n) {
  remainder := n % 4
  remainder == 0
}
